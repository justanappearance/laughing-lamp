from flask import (
    flash,
    Flask,
    redirect,
    render_template,
    request,
    Response,
    session,
    url_for,
)
import google.oauth2.credentials
import google_auth_oauthlib.flow
import googleapiclient.discovery
import html
import isodate
import json
import math
import os
import requests
import random
import re
import time

app = Flask(__name__)

app.secret_key = "This is my super secret key that no one is supposed to see."

CLIENT_SECRETS_FILE = "client_secret_43471750843-3amh1i9l27dp2eil5a19ak95gt0sf6n8.apps.googleusercontent.com.json"

SCOPES = ["https://www.googleapis.com/auth/youtube"]
API_SERVICE_NAME = "youtube"
API_VERSION = "v3"

os.environ["OAUTHLIB_INSECURE_TRANSPORT"] = "1"

DEBUG_MODE = True


def get_youtube_service():
    if "credentials" not in session:
        return redirect(url_for("authorize"))
    credentials = google.oauth2.credentials.Credentials(**session["credentials"])
    return googleapiclient.discovery.build(
        API_SERVICE_NAME, API_VERSION, credentials=credentials
    )


PLAYLISTS = {
    "hall_of_myths": {
        "display_name": "Hall of Myths",
        "description": "Vocaloid Songs That Have Reached 10,000,000+ Views On NicoNicoDouga",
        "list_id": 6477,
    },
    "hall_of_legends": {
        "display_name": "Hall of Legends",
        "description": "Vocaloid Songs That Have Reached 1,000,000+ Views On NicoNicoDouga",
        "list_id": 30,
    },
    "hall_of_fame": {
        "display_name": "Hall of Fame",
        "description": "Vocaloid Songs That Have Reached 100,000+ Views On NicoNicoDouga",
        "list_id": 186,
    },
}


def make_playlist(youtube, title):
    if DEBUG_MODE:
        return "PLuAYEy-JYPgJ05CzJXg745SmQatiJXmkN"
    request = youtube.playlists().insert(
        part="snippet,status",
        body={
            "snippet": {
                "title": title,
                "description": "A playlist generated by Vocaloid Playlist Creator",
            },
            "status": {"privacyStatus": "public"},
        },
    )

    try:
        response = request.execute()
        playlist_id = response["id"]

    except googleapiclient.errors.HttpError as e:
        print(f"Error: {e}")

    return playlist_id


def extract_video_id(url):
    if "youtu.be" in url:
        return url.split("/")[-1]
    elif "watch?v=" in url:
        return url.split("watch?v=")[-1].split("&")[0]


def get_video_with_highest_views(youtube, video_ids):
    request = youtube.videos().list(part="statistics", id=",".join(video_ids))
    response = request.execute()

    max_views = -1
    best_video_id = None

    # print(response)

    for item in response.get("items", []):
        video_id = item["id"]
        view_count = int(item["statistics"]["viewCount"])

        if view_count > max_views:
            max_views = view_count
            best_video_id = video_id

    return best_video_id


def search_youtube(youtube, song_title, artist=None, max_results=10):
    query = f"{song_title} {artist}" if artist else song_title

    request = youtube.search().list(
        q=query,
        part="snippet",
        maxResults=max_results,
        type="video",
        order="viewCount",
    )

    response = request.execute()

    return response["items"]


def get_video_details(youtube, video_ids):
    request = youtube.videos().list(
        part="contentDetails,statistics", id=",".join(video_ids)
    )
    response = request.execute()

    video_data = {}
    for item in response["items"]:
        video_id = item["id"]
        duration = item["contentDetails"]["duration"]
        view_count = int(item["statistics"]["viewCount"])
        video_data[video_id] = {"duration": duration, "view_count": view_count}
    return video_data


def convert_duration_to_seconds(iso_duration):
    duration = isodate.parse_duration(iso_duration)
    return int(duration.total_seconds())


def decide_on_best_video(vocadb_duration, video_data, tolerance=5):
    best_match = None
    best_score = -float("inf")

    for video_id, details in video_data.items():
        video_duration = convert_duration_to_seconds(details["duration"])
        view_count = int(details["view_count"])
        duration_diff = abs(video_duration - vocadb_duration)

        if duration_diff <= tolerance:
            penalty_factor = 1.0
        else:
            penalty_factor = 0.5 ** ((duration_diff - tolerance) / 10.0)

        score = (view_count / 1000.0) * penalty_factor

        if score > best_score:
            best_score = score
            best_match = video_id

    return best_match


def find_best_youtube_video(youtube, song_title, vocadb_duration, artist=None):
    search_results = search_youtube(youtube, song_title, artist)

    video_ids = [video["id"]["videoId"] for video in search_results]

    video_data = get_video_details(youtube, video_ids)

    best_video_id = decide_on_best_video(vocadb_duration, video_data)

    return best_video_id


def add_video_to_playlist(youtube, playlist_id, video_id):
    max_retries = 5
    delay = 1
    for attempt in range(max_retries):
        try:
            response = (
                youtube.playlistItems()
                .insert(
                    part="snippet",
                    body={
                        "snippet": {
                            "playlistId": playlist_id,
                            "resourceId": {
                                "kind": "youtube#video",
                                "videoId": video_id,
                            },
                        }
                    },
                )
                .execute()
            )
            return response

        except HttpError as e:
            error_details = e.content.decode() if hasattr(e, "content") else str(e)
            print(f"‚ö†Ô∏è Attempt {attempt+1} failed: {error_details}")

            if e.resp.status in [500, 503, 409]:
                wait_time = delay + random.uniform(0, 0.5)
                print(f"üîÑ Retrying in {wait_time:.2f} seconds...")
                time.sleep(wait_time)
                delay *= 2
            else:
                print("‚ùå Fatal error. Not retrying.")
                break
        print("üö® Max retries reached. Request failed.")
        return None


def add_to_playlist(
    youtube, list_id, playlist_id, MAX_RESULTS=50, start=0, total_count=None
):

    while total_count is None or start < total_count:
        response = requests.get(
            "https://vocadb.net/api/songLists/{list_id}/songs".format(list_id=list_id),
            params={
                "maxResults": MAX_RESULTS,
                "getTotalCount": True,
                "start": start,
            },
            timeout=10,
        )
        data_songs_from_list = response.json()
        # print(data)

        if total_count is None:
            total_count = data_songs_from_list["totalCount"]

        song_id_list = []
        for item in data_songs_from_list["items"]:
            song_id = item["song"]["id"]
            song_id_list.append(song_id)

        for song_id in song_id_list:
            url_get_song_by_id = f"https://vocadb.net/api/songs/{song_id}"
            response = requests.get(
                url_get_song_by_id, params={"fields": "PVs"}, timeout=10
            )
            data_songs_by_id = response.json()
            # print(data)
            youtube_video_ids_to_check, video_id_to_add = [], None
            for item in data_songs_by_id["pvs"]:
                if item["service"] != "Youtube" or item["pvType"] != "Original":
                    continue
                else:
                    url = item["url"]
                    youtube_video_ids_to_check.append(extract_video_id(url))

            if len(youtube_video_ids_to_check) > 1:
                video_id_to_add = get_video_with_highest_views(
                    youtube, youtube_video_ids_to_check
                )
            elif len(youtube_video_ids_to_check) == 1:
                video_id_to_add = youtube_video_ids_to_check[0]
            else:
                print(
                    f"No Original PVs Found for: {data_songs_by_id["defaultName"]} - {data_songs_by_id["artistString"]}"
                )
                video_id_to_add = find_best_youtube_video(
                    youtube,
                    data_songs_by_id["defaultName"],
                    data_songs_by_id["lengthSeconds"],
                    data_songs_by_id["artistString"],
                )

            add_video_to_playlist(youtube, playlist_id, video_id_to_add)

        start += MAX_RESULTS

    return


@app.route("/")
def index():
    youtube = get_youtube_service()
    if isinstance(youtube, Response):
        return youtube
    return render_template("index.html", playlists=PLAYLISTS)


@app.route("/create_playlist")
def create_playlist():
    youtube = get_youtube_service()
    playlist_key = request.args.get("playlist_key")
    if not playlist_key or playlist_key not in PLAYLISTS:
        return "Invalid playlist selection", 400

    playlist_data = PLAYLISTS[playlist_key]
    playlist_id = make_playlist(
        youtube, f"{playlist_data["display_name"]} - {playlist_data["description"]}"
    )
    # add_to_playlist(youtube, playlist_data["list_id"], playlist_id)

    playlist_url = f"https://www.youtube.com/playlist?list={playlist_id}"

    flash(
        f"‚úÖ Playlist '{playlist_data['display_name']}' created successfully! "
        f"<a href='{playlist_url}' target='_blank' class='btn btn-success btn-sm'> View Playlist</a>",
        "success",
    )
    return redirect(url_for("index"))


@app.route("/authorize")
def authorize():
    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
        CLIENT_SECRETS_FILE, scopes=SCOPES
    )

    flow.redirect_uri = url_for("oauth2callback", _external=True)

    authorization_url, state = flow.authorization_url(
        access_type="offline", include_granted_scopes="true"
    )

    session["state"] = state
    return redirect(authorization_url)


@app.route("/oauth2callback")
def oauth2callback():
    state = session.get("state")

    flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(
        CLIENT_SECRETS_FILE, scopes=SCOPES, state=state
    )
    flow.redirect_uri = url_for("oauth2callback", _external=True)

    flow.fetch_token(authorization_response=request.url)

    credentials = flow.credentials
    session["credentials"] = {
        "token": credentials.token,
        "refresh_token": credentials.refresh_token,
        "token_uri": credentials.token_uri,
        "client_id": credentials.client_id,
        "client_secret": credentials.client_secret,
        "scopes": credentials.scopes,
    }

    return redirect(url_for("index"))


@app.route("/clear")
def clear_credentials():
    session.clear()
    return redirect(url_for("index"))


if __name__ == "__main__":
    app.run("localhost", 8080, debug=True)
